---
layout:       post
title:        "1.滑动窗口与双指针"
author:       "AJohn"
header-style: text
catalog:      true
tags:
    - Blog
    - leetcode
---

>根据灵神的题单做的个人笔记，仅学习使用，不做任何商业用途

# 【题单】滑动窗口与双指针（定长/不定长/至多/至少/恰好/单序列/双序列/三指针）

## 一、定长滑动窗口
### 1.1 基础

**定长滑窗套路**
我总结成三步：入-更新-出。
![](https://cdn.jsdelivr.net/gh/zzyAJohn/Image/post-leetcode-1.png)
1. 入：下标为 i 的元素进入窗口，更新相关统计量。如果 i<k−1 则重复第一步。
1. 更新：更新答案。一般是更新最大值/最小值。
1. 出：下标为 i−k+1 的元素离开窗口，更新相关统计量。
以上三步适用于所有定长滑窗题目。

***阿囧说：代码实操中，先滑到k个窗口大小，然后位于s[i+1-k]的字符（想象指针回退k个窗口大小）先出，如果还有新字符则再次进循环，入新字符***

1. [定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/description/)

    ```py
    class Solution:
    def maxVowels(self, s: str, k: int) -> int:
        yuanYin = "aeiou"
        res = 0
        temp = 0
        for i, c in enumerate(s):
            if c in yuanYin:
                temp += 1
            if i + 1 < k:
                continue
            res = max(res, temp)
            if s[i + 1 - k] in yuanYin:
                temp -= 1
        return res
    ```
    时间复杂度：O(n)

    空间复杂度：O(1)

2. [643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/description/)

    ```py
    class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        res, temp = float('-inf'), 0
        for i, num in enumerate(nums):
            temp += num
            if i + 1 < k:
                continue
            res = max(temp, res)
            temp -= nums[i + 1 - k]
        res /= k
        return res
    ```

    时间复杂度：O(n)

    空间复杂度：O(1)

3. [1343. 大小为 K 且平均值大于等于阈值的子数组数目](https://leetcode.cn/problems/number-of-sub-arrays-of-size-k-and-average-greater-than-or-equal-to-threshold/description/)

    ```py
    class Solution:
    def numOfSubarrays(self, arr: List[int], k: int, threshold: int) -> int:
        temp, res = 0, 0
        for i, num in enumerate(arr):
            temp += num
            if i + 1 < k:
                continue
            if temp / k >= threshold:
                res += 1
            temp -= arr[i + 1 - k]
        return res
    ```

    时间复杂度：O(n)

    空间复杂度：O(1)

4. [2090. 半径为 k 的子数组平均值](https://leetcode.cn/problems/k-radius-subarray-averages/)

    ~~我的丑陋解法：~~
    ```py
    class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        res = []
        temp, start = 0, 0
        n = len(nums)
        if n <= 2 * k:
            res = [-1] * n
            return res
        else:
            for _ in range(k):
                res.append(-1)
            for i in range(k):
                start += nums[i]
            for i, num in enumerate(nums):
                start += nums[i + k]
                if i < k:
                    continue
                res.append(start // (2 * k + 1))
                start -= nums[i - k]
                if i + k + 1 == n:
                    for _ in range(k):
                        res.append(-1)
                    break
        return res 
    ```

    时间复杂度：O(n)

    空间复杂度：O(n)

    **tips：但其实i应该滑到窗口的末端而不是中间，代码会简便很多**

    ```py
    class Solution:
    def getAverages(self, nums: List[int], k: int) -> List[int]:
        n = len(nums)
        res = [-1] * n
        temp = 0
        for i, num in enumerate(nums):
            temp += num
            if i < 2 * k:
                continue
            res[i - k] = temp // (2 * k + 1)
            temp -= nums[i - 2 * k]
        return res
    ```

    时间复杂度：O(n)

    空间复杂度：O(n)